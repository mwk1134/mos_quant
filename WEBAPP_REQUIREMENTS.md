# SOXL 퀀트투자 웹앱 (app.py) 구현 요구사항서

> **대상 종목**: SOXL (3x 레버리지 반도체 ETF)  
> **프레임워크**: Streamlit  
> **핵심 엔진**: `soxl_quant_system.py`의 `SOXLQuantTrader` 클래스  
> **배포**: Streamlit Cloud

---

## 목차

1. [시스템 개요](#1-시스템-개요)
2. [핵심 매매 로직 (완전 명세)](#2-핵심-매매-로직-완전-명세)
3. [웹앱 구조 및 페이지](#3-웹앱-구조-및-페이지)
4. [데이터 흐름 및 초기화](#4-데이터-흐름-및-초기화)
5. [세션 상태 관리](#5-세션-상태-관리)
6. [UI/UX 요구사항](#6-uiux-요구사항)
7. [외부 데이터 의존성](#7-외부-데이터-의존성)
8. [에러 처리 및 폴백](#8-에러-처리-및-폴백)

---

## 1. 시스템 개요

### 1.1 목적
- 사용자가 설정한 **투자 시작일**과 **초기 투자금**을 기반으로, 시작일부터 오늘까지의 매매를 **자동 시뮬레이션**하여 현재 보유 포지션 상태를 산출한다.
- 산출된 포지션 상태에서 **오늘의 매수/매도 추천**을 생성한다.
- 과거 구간에 대한 **백테스팅**을 수행하고 결과를 시각화한다.

### 1.2 핵심 개념
| 개념 | 설명 |
|------|------|
| **모드** | 안전모드(SF) 또는 공세모드(AG). QQQ 주간 RSI로 결정 |
| **분할매수** | 투자원금을 모드별 비율로 나눠 회차별로 매수 |
| **LOC 주문** | Limit on Close - 종가 기준 지정가 주문 방식 |
| **손절예정일** | 매수 후 최대 보유기간(거래일 기준) 경과 시 종가에 LOC 매도 |
| **투자원금 갱신** | 10거래일마다 총자산(현금 + 평가금액)으로 투자원금을 갱신 |
| **시드증액** | 사용자가 추가 입금/인출한 금액을 반영 |

---

## 2. 핵심 매매 로직 (완전 명세)

### 2.1 모드 결정 (SF/AG) - QQQ 주간 RSI 기반

#### 2.1.1 주간 RSI 계산 방법
- **대상**: QQQ (나스닥 100 ETF)
- **RSI 기간**: 14주 (window=14)
- **주간 데이터 변환**: 일별 데이터를 금요일 기준(`W-FRI`)으로 리샘플링
  - Open: first, High: max, Low: min, Close: last, Volume: sum
- **RSI 공식**:
  ```
  delta = weekly_close.diff()
  gain = (delta > 0 인 경우 delta, 아니면 0).rolling(14).mean()
  loss = (delta < 0 인 경우 |delta|, 아니면 0).rolling(14).mean()
  RS = gain / loss
  RSI = 100 - (100 / (1 + RS))
  ```
- **데이터 소스 우선순위**:
  1. `data/weekly_rsi_reference.json` (사전 계산된 참조 데이터)
  2. 참조 데이터에 없으면 → **5년치 QQQ 데이터**로 실시간 계산 (6개월 X, 반드시 5년)

#### 2.1.2 모드 판단에 사용하는 RSI
- **1주전 RSI** = 지난주 금요일 기준 RSI (`latest_completed_friday`)
- **2주전 RSI** = 지지난주 금요일 기준 RSI (`latest_completed_friday - 7일`)
- **항상 지난주 금요일을 기준**으로 한다. 금요일이어도 이번 주 금요일의 RSI가 아닌, 지난주 금요일의 RSI를 사용한다.

#### 2.1.3 안전모드(SF) 전환 조건 (OR - 하나라도 충족 시)
| 조건 | 설명 |
|------|------|
| **조건1** | 2주전 RSI > 65 이고, 2주전 RSI > 1주전 RSI (RSI 65 이상에서 하락) |
| **조건2** | 40 < 2주전 RSI < 50 이고, 2주전 RSI > 1주전 RSI (40~50 영역에서 하락) |
| **조건3** | 2주전 RSI >= 50 이고, 1주전 RSI < 50 (RSI가 50 밑으로 하락) |

#### 2.1.4 공세모드(AG) 전환 조건 (OR - 하나라도 충족 시)
| 조건 | 설명 |
|------|------|
| **조건1** | 2주전 RSI < 50 이고, 2주전 RSI < 1주전 RSI 이고, 1주전 RSI > 50 (RSI가 50 위로 상승) |
| **조건2** | 50 < 2주전 RSI < 60 이고, 2주전 RSI < 1주전 RSI (50~60 영역에서 상승) |
| **조건3** | 2주전 RSI < 35 이고, 2주전 RSI < 1주전 RSI (RSI 35 미만에서 상승) |

#### 2.1.5 모드 결정 흐름
```
1. 위 안전모드 3조건 / 공세모드 3조건을 확인
2. 안전모드 조건 충족 → SF 모드
3. 공세모드 조건 충족 → AG 모드
4. 어느 조건에도 해당하지 않으면 → 전주 모드 유지
5. 전주 모드가 없으면 → 재귀적으로 이전 주차의 조건을 확인하여 최초로 조건에 해당하는 모드를 찾음
```

#### 2.1.6 모드 업데이트 타이밍 (매우 중요!)
- **월~금은 모드가 변경되지 않는다** (같은 주 내 모드 유지 원칙)
- **금요일 장 종료(미국 동부시간 16:00) 이후**에만 새로운 주의 모드를 계산
- 금요일 장 종료 전에는 현재 주 모드를 그대로 유지
- **월요일**에는 항상 모드를 재계산 (이번 주 모드를 새로 설정)
- 모드 계산 시 사용하는 RSI는 **항상 지난주 금요일과 지지난주 금요일** 기준

---

### 2.2 매수 로직

#### 2.2.1 매수가 계산
```
매수가 = 전일 종가 × (1 + buy_threshold / 100)
```
- **전일 종가 결정**: 장이 마감되지 않았으면 전 거래일 종가, 마감 후면 당일 종가를 "전일 종가"로 사용

#### 2.2.2 매수 조건
```
당일 종가 >= 매수가 → LOC 매수 체결
```
- LOC(Limit on Close) 방식: 종가가 매수가 이상이면 종가에 체결

#### 2.2.3 분할매수 회차별 매수금액
```
회차별 매수금액 = 투자원금 × split_ratios[회차-1]
매수 수량 = int(회차별 매수금액 / 매수가)     ← 정수(소수점 절삭)
실제 매수금액 = 매수 수량 × 실제 매수가(종가)
```

#### 2.2.4 예수금 부족 시
```
가능 수량 = int(잔여 예수금 / 매수가)
가능 수량 > 0 이면 → 가능한 만큼 매수
가능 수량 = 0 이면 → 매수 불가
```

#### 2.2.5 최대 분할매수 횟수
- SF 모드: 7회
- AG 모드: 8회
- 모든 회차 매수 완료 시 추가 매수 불가

---

### 2.3 매도 로직

#### 2.3.1 매도 목표가 (LOC 매도)
```
매도 목표가 = 매수 체결가 × (1 + sell_threshold / 100)
```
- **중요**: 매도 목표가는 포지션의 **매수 시점 모드** 기준으로 계산
  - 예: AG 모드에서 매수한 포지션은 현재 모드가 SF여도 AG의 sell_threshold 사용

#### 2.3.2 매도 체결 조건
```
당일 종가 >= 매도 목표가 → LOC 매도 체결 (종가에 매도)
```

#### 2.3.3 손절 (최대 보유기간 경과)
```
매수일로부터 max_hold_days(거래일 기준) 경과 시 → 종가에 LOC 매도
```
- **거래일 기준**: 주말(토,일) + 미국 증시 휴장일 제외
- SF 모드: 최대 35거래일
- AG 모드: 최대 7거래일

#### 2.3.4 과거 종가 기반 자동 보정 (reconcile)
- 시뮬레이션 완료 후, 보유 포지션에 대해 과거 종가 데이터를 역추적
- 매도 목표가를 이미 터치한 날이 있으면 그 날에 매도 처리
- 손절예정일이 지난 포지션도 자동 매도 처리
- **장중에는 오늘 날짜 데이터 제외** (종가 미확정)

---

### 2.4 모드별 설정값

#### 2.4.1 안전모드 (SF) 기본값
| 파라미터 | 값 | 설명 |
|----------|-----|------|
| buy_threshold | 3.5% | 전일 종가 대비 매수 임계값 |
| sell_threshold | 1.4% | 매수가 대비 매도 임계값 |
| max_hold_days | 35 | 최대 보유 거래일 |
| split_count | 7 | 분할매수 횟수 |
| split_ratios | [0.049, 0.127, 0.230, 0.257, 0.028, 0.169, 0.140] | 회차별 투자 비율 |

#### 2.4.2 공세모드 (AG) 기본값
| 파라미터 | 값 | 설명 |
|----------|-----|------|
| buy_threshold | 3.6% | 전일 종가 대비 매수 임계값 |
| sell_threshold | 3.5% | 매수가 대비 매도 임계값 |
| max_hold_days | 7 | 최대 보유 거래일 |
| split_count | 8 | 분할매수 횟수 |
| split_ratios | [0.062, 0.134, 0.118, 0.148, 0.150, 0.182, 0.186, 0.020] | 회차별 투자 비율 |

#### 2.4.3 설정값은 웹앱의 "⚙️ 설정" 탭에서 사용자가 수정 가능
- 수정 시 트레이더 인스턴스를 재초기화하여 반영

---

### 2.5 투자원금 갱신 로직
```
10거래일마다:
  투자원금 = 현재 예수금 + Σ(보유 포지션의 주식수 × 현재가)
```
- 갱신된 투자원금은 이후 회차별 매수금액 계산에 사용

---

### 2.6 시드증액/인출
- 사용자가 특정 날짜에 금액을 추가 입금하거나 인출할 수 있음
- 양수: 시드증액 (예수금 증가)
- 음수: 시드인출 (예수금 감소)
- 시뮬레이션 시 해당 날짜에 자동 반영

---

## 3. 웹앱 구조 및 페이지

### 3.1 인증
- **로그인 페이지**: 시스템 접속 전 ID/PW 입력 필요
- ID: `mosmos`, PW: `mosmos!`
- 세션 기반 인증 (새로고침 시 유지, 앱 재시작 시 재로그인)

### 3.2 메인 레이아웃
- **사이드바**: 숨김 처리 (CSS로 `display: none`)
- **헤더**: "📈 SOXL 퀀트투자 시스템"
- **한국시간 표시**: UTC+9 기준 현재 시각
- **설정 패널**: 투자금, 시작일, 프리셋, 시드증액 (항상 상단에 표시)
- **3개 탭**: 📊 오늘의 매매 | 📈 백테스팅 | ⚙️ 설정

### 3.3 설정 패널 (모든 탭 위에 공통 표시)

#### 3.3.1 기본 설정
- **초기 투자금** (달러, number_input, 기본값: 9000)
- **투자 시작일** (date_input)

#### 3.3.2 사용자 프리셋 시스템
4개의 프리셋 버튼 + 각각의 저장 버튼:

| 프리셋 | 초기투자금 | 시작일 | 시드증액 |
|--------|-----------|--------|---------|
| **KMW** | $9,000 | 2025-08-27 | 2025-10-21 +$31,000 |
| **JEH** | $2,793 | 2025-10-30 | 2025-12-22 +$13,499, 2026-01-15 +$2,035 |
| **JSD** | $17,300 | 2025-10-30 | 없음 |
| **JEH2** | $2,704 | 2025-12-22 | 2026-01-15 +$678 |

- 프리셋 불러오기: 해당 프리셋의 설정값 + 포지션 수정 정보 복원
- 프리셋 저장: 현재 설정값 + 포지션 수정 정보를 프리셋에 저장

#### 3.3.3 시드증액 관리
- 시드증액 목록 표시 (날짜 + 금액 + 삭제 버튼)
- 시드증액 추가 폼 (날짜 + 금액 + 추가 버튼)
- 양수: 입금, 음수: 인출

---

### 3.4 탭1: 📊 오늘의 매매

#### 3.4.1 처리 흐름
```
1. 캐시 클리어
2. simulate_from_start_to_today(시작일) → 시작일~오늘 시뮬레이션
3. 저장된 포지션 수정 정보 복원 (position_edits)
4. get_daily_recommendation() → 오늘의 매매 추천 생성
5. 결과 표시
```

#### 3.4.2 표시 항목

**상단 정보 (2열)**
| 왼쪽 | 오른쪽 |
|------|--------|
| 📅 날짜 | 📊 QQQ 주간 RSI (1주전 / 2주전) |
| 🎯 모드: SF/AG (안전모드/공세모드) | 💰 SOXL 현재가 |

**매수 추천 (왼쪽 열)**
- 잔여 예수금
- 매수 가능 시: 회차, 매수가(LOC), 매수금액, 매수주식수
- 예수금 부족 시: 가능한 매수 수량 안내
- 장중 주문 가이드 (현재가 vs 매수가 비교)

**매도 추천 (오른쪽 열)**
- 보유 포지션별: 회차, 목표가, 현재가, 목표까지 차이(%), 모드, 손절예정일
- 매도 조건 충족 시: 매도 추천 표시
- 디버깅 정보: 매도 조건 확인 expander

**포트폴리오 현황**
- 보유 포지션 수, 투자원금, 평가손익, 총 자산

**보유 포지션 상세 테이블**
- 회차, 매수체결일, 모드, 주식수, 매수가, 매도목표가, 보유일, 평가금액, 손익, 수익률

**포지션 수정 기능**
- selectbox로 수정할 포지션 선택
- 주식수, 매수가 수정 가능
- 수정 시 차액을 예수금에 반영
- 수정 정보는 `position_edits`에 저장되어 시뮬레이션 후에도 복원됨
- 키 형식: `{회차}_{매수일}` → `{'shares': int, 'buy_price': float}`

---

### 3.5 탭2: 📈 백테스팅

#### 3.5.1 설정
- 시작 날짜 / 종료 날짜 (date_input)
- "🚀 백테스팅 실행" 버튼

#### 3.5.2 결과 표시
- **요약**: 초기자본, 최종자산, 총수익률, 최종포지션 수
- **리스크 지표**: MDD(%), MDD 발생일, 최저자산
- **자산 변화 차트**: Plotly 라인차트 (x: 날짜, y: 총자산)
- **상세 거래 내역 테이블**: 날짜, 주차, RSI, 모드, 회차, 매수가, 수량, 매수금액, 매도가, 실현손익
- **엑셀 다운로드**: 백테스팅 결과를 엑셀 파일로 다운로드

---

### 3.6 탭3: ⚙️ 설정

#### 3.6.1 RSI 참조 데이터 관리
- "🔄 RSI 데이터 업데이트" 버튼
- "📋 RSI 데이터 상태 확인" 버튼

#### 3.6.2 모드 설정 편집 (SF / AG)
- 각 모드별: 매수 임계값, 매도 임계값, 최대 보유일수, 분할매수 횟수
- 회차별 분할 비율 입력 (number_input)
- 비율 합이 1.0이 아니면 경고 표시
- 변경 감지 시 자동으로 트레이더 재초기화

#### 3.6.3 시스템 정보
- 초기 투자금, 현재 투자원금, 세션 시작일, 현재 모드, 현재 회차
- 최근 거래일, 현금잔고, 보유 포지션 수
- "🔄 시스템 재시작" 버튼

---

## 4. 데이터 흐름 및 초기화

### 4.1 트레이더 초기화 흐름
```
1. SOXLQuantTrader(initial_capital, sf_config, ag_config) 생성
2. test_today_override 설정 (있으면)
3. 시드증액 데이터 추가 (add_seed_increase)
4. RSI 참조 데이터 최신 여부 확인
   - 최신 아니면 → update_rsi_reference_file() 자동 실행
5. 트레이더 준비 완료
```

### 4.2 시뮬레이션 흐름 (simulate_from_start_to_today)
```
1. 포트폴리오 초기화 (reset_portfolio)
2. start_date ~ latest_trading_day 구간에 대해 run_backtest 실행
3. 각 거래일마다:
   a. 시드증액 확인 및 반영
   b. 해당 주의 모드 결정 (QQQ 주간 RSI 기반)
   c. 매수 조건 확인 → 체결 시 execute_buy
   d. 매도 조건 확인 → 체결 시 execute_sell
   e. 10거래일마다 투자원금 갱신
4. 시뮬레이션 결과 캐시 (30초)
```

### 4.3 일일 추천 생성 흐름 (get_daily_recommendation)
```
1. 시뮬레이션 실행 (시작일 ~ 오늘)
2. 포지션 수정 정보 복원
3. QQQ 6개월 데이터 로드
4. SOXL 1개월 데이터 로드
5. 과거 종가 기반 포지션 보정 (reconcile)
6. 모드 결정:
   - 같은 주 + 모드 설정됨 + 월요일 아님 → 유지 (검증 후)
   - 월요일 → 재계산
   - 새로운 주 → 재계산 (금요일 장전이면 유지)
7. RSI 값 추출 (참조 데이터 우선, 없으면 5년 실시간 계산)
8. 매수가/매도가 계산
9. 포트폴리오 현황 집계
10. 추천 딕셔너리 반환
```

### 4.4 추천 딕셔너리 구조
```python
{
    "date": "2026-02-06",
    "mode": "AG",  # 또는 "SF"
    "qqq_one_week_ago_rsi": 51.70,
    "qqq_two_weeks_ago_rsi": 56.15,
    "soxl_current_price": 25.50,
    "basis_date": "2026-02-05",  # 가격 계산 기준일
    "can_buy": True,
    "next_buy_round": 3,
    "buy_price": 26.39,
    "next_buy_amount": 3450.0,
    "sell_recommendations": [...],  # 매도 추천 리스트
    "sell_debug_info": [...],       # 매도 조건 디버깅 정보
    "reconcile_debug_info": {...},  # 보정 전후 비교
    "portfolio": {
        "positions_count": 2,
        "total_invested": 5000.0,
        "total_position_value": 5200.0,
        "unrealized_pnl": 200.0,
        "available_cash": 4000.0,
        "total_portfolio_value": 9200.0
    }
}
```

---

## 5. 세션 상태 관리

### 5.1 세션 변수 목록

| 변수명 | 타입 | 기본값 | 설명 |
|--------|------|--------|------|
| `trader` | SOXLQuantTrader | None | 트레이더 인스턴스 |
| `initial_capital` | float | 9000 | 초기 투자금 |
| `session_start_date` | str | "2025-08-27" | 투자 시작일 |
| `test_today_override` | str | 오늘 날짜 | 테스트용 날짜 오버라이드 |
| `authenticated` | bool | False | 로그인 여부 |
| `position_edits` | dict | {} | 포지션 수정 정보 |
| `seed_increases` | list | [] | 시드증액 목록 |
| `kmw_preset` | dict | {...} | KMW 프리셋 |
| `jeh_preset` | dict | {...} | JEH 프리셋 |
| `jsd_preset` | dict | {...} | JSD 프리셋 |
| `jeh2_preset` | dict | {...} | JEH2 프리셋 |
| `sf_config` | dict | None | SF 모드 커스텀 설정 |
| `ag_config` | dict | None | AG 모드 커스텀 설정 |
| `backtest_result` | dict | None | 백테스팅 결과 |
| `active_tab` | int | None | 활성 탭 인덱스 |

### 5.2 트레이더 재초기화 트리거
다음 상황에서 `st.session_state.trader = None` 설정 후 재초기화:
- 초기 투자금 변경
- 투자 시작일 변경
- 프리셋 불러오기
- 시드증액 추가/삭제
- SF/AG 모드 파라미터 변경
- 시스템 재시작 버튼

---

## 6. UI/UX 요구사항

### 6.1 모바일 최적화
- 반응형 레이아웃 (`layout="wide"`)
- 모바일 브레이크포인트: 768px, 480px
- 모바일에서 버튼 `width: 100%`
- 폰트 크기 자동 조정
- 사이드바 완전 숨김

### 6.2 모드 표시 스타일
- SF (안전모드): **초록색** (#28a745)
- AG (공세모드): **주황색** (#ff8c00)
- 손절예정일: **빨간색** (#DC3545)

### 6.3 데이터 경고
- SOXL 종가 데이터 누락 시 경고 배너
- RSI 계산 불가 시 에러 메시지

### 6.4 차트
- **Plotly** 사용 (go.Figure, px.bar)
- 자산 변화: 라인 차트
- 포지션별 수익률: 바 차트
- 자산 구성: 파이 차트

---

## 7. 외부 데이터 의존성

### 7.1 Yahoo Finance API
- **URL**: `https://query1.finance.yahoo.com/v8/finance/chart/{symbol}`
- **종목**: SOXL (매매 대상), QQQ (모드 결정용)
- **기간 옵션**: 1d, 5d, 1mo, 3mo, 6mo, 1y, 2y, 5y, 10y, 15y, max
- **캐시**: 1분
- **User-Agent**: Mozilla 브라우저 시뮬레이션

### 7.2 RSI 참조 데이터
- **파일**: `data/weekly_rsi_reference.json`
- **구조**: 연도별 → 주차별 → { friday_date, rsi_value, close }
- **업데이트**: 트레이더 초기화 시 자동 확인, 최신 아니면 자동 업데이트
- **업데이트 시 데이터 기간**: 5년 QQQ 데이터 사용

### 7.3 미국 증시 휴장일
- 2024~2025년 휴장일 하드코딩
- 주말(토,일) + 휴장일 = 비거래일

### 7.4 미국 동부시간(ET) 계산
- 서머타임(3~10월): UTC-4
- 겨울: UTC-5
- 정규장 시간: 09:30~16:00 ET
- `is_regular_session_closed_now()`: 16:00 ET 이후면 장 마감

---

## 8. 에러 처리 및 폴백

### 8.1 RSI 참조 데이터 없을 때
```
1순위: weekly_rsi_reference.json에서 조회
2순위: 5년치 QQQ 데이터로 실시간 계산 (calculate_weekly_rsi_for_dates)
3순위: 계산 실패 시 "QQQ 주간 RSI를 계산할 수 없습니다" 에러 반환
```

### 8.2 모드 판정 실패
```
- 전주 모드를 재귀적으로 최대 20주까지 추적
- 참조 데이터 버전 실패 → 실시간 계산 버전으로 재시도
- 완전 실패 시 → "모드 판정 실패" 에러 반환
```

### 8.3 주식 데이터 API 실패
```
- 15y 지원 안 되면 → 10y로 대체
- API 실패 시 → 에러 메시지 표시 + 페이지 새로고침 안내
```

### 8.4 시뮬레이션 실패
```
- 시작일 > 종료일 → 시뮬레이션 스킵, 포트폴리오 초기화만 수행
- 데이터 부족 → 에러 메시지 표시
```

### 8.5 종가 데이터 NULL 처리
- Yahoo Finance에서 Close가 None인 날짜는 제거
- 해당 날짜들은 `_data_warnings`에 기록하여 웹앱에서 경고 표시
- 수동 보정 딕셔너리 (`manual_corrections`)로 특정 날짜의 종가를 수동 지정 가능

---

## 부록: 포지션 보정 특수 규칙

### A.1 모드 전환 시 기존 포지션 보정
- 모드가 바뀌면(예: SF→AG), 해당 주에 새로 매수되는 포지션은 새 모드로 매수
- 기존 보유 포지션의 모드는 **매수 시점의 모드**를 유지 (매도 목표가/손절 기간은 매수 시점 모드 기준)

### A.2 투자원금 계산 시 모드별 분리 없음
- 투자원금은 모드와 무관하게 **총 자산**으로 갱신
- 회차별 매수금액 계산은 **현재 활성 모드**의 `split_ratios` 사용

### A.3 12/29일 특수 보정
- 해당 날짜의 포지션을 SF 모드로 강제 변경하는 하드코딩된 보정 로직이 존재
- (특정 히스토리컬 케이스 대응)

---

> **이 문서를 기반으로 `app.py`를 처음부터 구현할 때, `soxl_quant_system.py`의 `SOXLQuantTrader` 클래스를 import하여 사용하면 됩니다. 매매 로직의 핵심 계산은 모두 `SOXLQuantTrader` 내부에서 처리되며, `app.py`는 이를 호출하여 결과를 Streamlit UI로 렌더링하는 역할을 합니다.**

